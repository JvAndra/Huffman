#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include "huffman_logic.hpp" 


// O mapa abaixo é apenas um EXEMPLO
const std::map<std::string, unsigned long long> FIXED_FREQUENCY_MAP = {
    {"\n", 366},
    {" ", 2344},
    {"!", 6},
    {"\"", 855},
    {"#", 2},
    {"#define", 3},
    {"#elif", 3},
    {"#else", 3},
    {"#endif", 3},
    {"#if", 3},
    {"#ifdef", 3},
    {"#ifndef", 3},
    {"#include", 16},
    {"&", 9},
    {"'", 19},
    {"(", 59},
    {")", 59},
    {"*", 3},
    {"+", 23},
    {",", 616},
    {"-", 7},
    {".", 33},
    {"/", 35},
    {"0", 15},
    {"1", 57},
    {"2", 115},
    {"3", 20},
    {"4", 17},
    {"5", 14},
    {"6", 21},
    {"7", 16},
    {"8", 16},
    {"9", 16},
    {":", 126},
    {";", 70},
    {"<", 94},
    {"=", 167},
    {">", 26},
    {"A", 13},
    {"B", 2},
    {"C", 13},
    {"D", 12},
    {"E", 26},
    {"F", 17},
    {"G", 2},
    {"H", 3},
    {"I", 7},
    {"J", 1},
    {"K", 6},
    {"L", 5},
    {"M", 8},
    {"N", 8},
    {"O", 13},
    {"P", 18},
    {"Q", 5},
    {"R", 11},
    {"S", 9},
    {"T", 4},
    {"U", 8},
    {"V", 1},
    {"W", 6},
    {"X", 6},
    {"Y", 9},
    {"Z", 1},
    {"[", 14},
    {"\\", 24},
    {"]", 14},
    {"_", 67},
    {"a", 163},
    {"alignas", 3},
    {"alignof", 3},
    {"and", 3},
    {"and_eq", 3},
    {"asm", 3},
    {"auto", 4},
    {"b", 20},
    {"bitand", 3},
    {"bitor", 3},
    {"bool", 3},
    {"break", 9},
    {"c", 85},
    {"case", 8},
    {"catch", 3},
    {"char", 9},
    {"char16_t", 3},
    {"char32_t", 3},
    {"char8_t", 3},
    {"class", 3},
    {"co_await", 3},
    {"co_return", 3},
    {"co_yield", 3},
    {"compl", 3},
    {"concept", 3},
    {"const", 10},
    {"const_cast", 3},
    {"consteval", 3},
    {"constexpr", 3},
    {"constinit", 3},
    {"continue", 3},
    {"d", 128},
    {"decltype", 3},
    {"default", 4},
    {"delete", 3},
    {"do", 4},
    {"double", 3},
    {"dynamic_cast", 3},
    {"e", 205},
    {"else", 9},
    {"enum", 3},
    {"explicit", 3},
    {"export", 3},
    {"extern", 3},
    {"f", 73},
    {"false", 3},
    {"float", 3},
    {"for", 8},
    {"friend", 3},
    {"g", 49},
    {"goto", 3},
    {"h", 9},
    {"i", 127},
    {"if", 13},
    {"inline", 3},
    {"int", 8},
    {"j", 1},
    {"k", 6},
    {"l", 67},
    {"long", 11},
    {"m", 69},
    {"mutable", 3},
    {"n", 91},
    {"namespace", 3},
    {"new", 3},
    {"noexcept", 3},
    {"not", 3},
    {"not_eq", 3},
    {"nullptr", 3},
    {"o", 138},
    {"operator", 3},
    {"or", 3},
    {"or_eq", 3},
    {"p", 96},
    {"private", 3},
    {"protected", 3},
    {"public", 3},
    {"q", 21},
    {"r", 175},
    {"register", 3},
    {"reinterpret_cast", 3},
    {"requires", 3},
    {"return", 11},
    {"s", 157},
    {"short", 3},
    {"signed", 3},
    {"sizeof", 3},
    {"static", 3},
    {"static_assert", 3},
    {"static_cast", 3},
    {"struct", 3},
    {"switch", 4},
    {"t", 190},
    {"template", 3},
    {"this", 3},
    {"thread_local", 3},
    {"throw", 3},
    {"true", 3},
    {"try", 3},
    {"typedef", 3},
    {"typeid", 3},
    {"typename", 3},
    {"u", 97},
    {"union", 3},
    {"unsigned", 7},
    {"using", 3},
    {"v", 28},
    {"virtual", 3},
    {"void", 5},
    {"volatile", 3},
    {"w", 14},
    {"wchar_t", 3},
    {"while", 6},
    {"x", 5},
    {"xor", 3},
    {"xor_eq", 3},
    {"y", 5},
    {"z", 1},
    {"{", 233},
    {"|", 5},
    {"}", 233},
    {"€", 1},
    {"", 1},
    {"ƒ", 2},
    {"‡", 1},
    {"’", 1},
    {" ", 1},
    {"¡", 3},
    {"£", 9},
    {"§", 4},
    {"©", 3},
    {"ª", 1},
    {"³", 3},
    {"Â", 6},
    {"Ã", 20},
    {"Å", 1},
    {"Æ", 1},
    {"â", 1},
};

// A lista de palavras-chave deve ser consistente com a usada no contador.
const std::set<std::string> CPP_KEYWORDS = {
    "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor",
    "bool", "break", "case", "catch", "char", "char8_t", "char16_t", "char32_t",
    "class", "compl", "concept", "const", "consteval", "constexpr", "constinit",
    "const_cast", "continue", "co_await", "co_return", "co_yield", "decltype",
    "default", "delete", "do", "double", "dynamic_cast", "else", "enum",
    "explicit", "export", "extern", "false", "float", "for", "friend", "goto",
    "if", "inline", "int", "long", "mutable", "namespace", "new", "noexcept",
    "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private",
    "protected", "public", "register", "reinterpret_cast", "requires", "return",
    "short", "signed", "sizeof", "static", "static_assert", "static_cast",
    "struct", "switch", "template", "this", "thread_local", "throw", "true",
    "try", "typedef", "typeid", "typename", "union", "unsigned", "using",
    "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq", 
    "#include", "#define", "#ifdef", "#ifndef", "#endif", "#if", "#else", "#elif"
};


void print_usage() {
    std::cout << "Uso: " << std::endl;
    std::cout << "  Para comprimir:   ./compressor -c <arquivo_de_entrada> <arquivo_de_saida>" << std::endl;
    std::cout << "  Para descomprimir: ./compressor -d <arquivo_de_entrada> <arquivo_de_saida>" << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        print_usage();
        return 1;
    }

    std::string mode = argv[1];
    std::string input_filename = argv[2];
    std::string output_filename = argv[3];

    // Construir a árvore e os códigos a partir do mapa FIXO.
    std::shared_ptr<Node> root = buildHuffmanTree(FIXED_FREQUENCY_MAP);
    
    if (mode == "-c") {
        std::cout << "Modo: Comprimir" << std::endl;
        std::map<std::string, std::string> codes = generateCodes(root);
        compressFile(input_filename, output_filename, codes, CPP_KEYWORDS);
    } else if (mode == "-d") {
        std::cout << "Modo: Descomprimir" << std::endl;
        decompressFile(input_filename, output_filename, root);
    } else {
        print_usage();
        return 1;
    }

    return 0;
}